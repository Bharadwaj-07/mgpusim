// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.com/akita/akita (interfaces: Port)

package timing

import (
	gomock "github.com/golang/mock/gomock"
	akita "gitlab.com/akita/akita"
	reflect "reflect"
)

// MockPort is a mock of Port interface
type MockPort struct {
	ctrl     *gomock.Controller
	recorder *MockPortMockRecorder
}

// MockPortMockRecorder is the mock recorder for MockPort
type MockPortMockRecorder struct {
	mock *MockPort
}

// NewMockPort creates a new mock instance
func NewMockPort(ctrl *gomock.Controller) *MockPort {
	mock := &MockPort{ctrl: ctrl}
	mock.recorder = &MockPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockPort) EXPECT() *MockPortMockRecorder {
	return m.recorder
}

// Component mocks base method
func (m *MockPort) Component() akita.Component {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Component")
	ret0, _ := ret[0].(akita.Component)
	return ret0
}

// Component indicates an expected call of Component
func (mr *MockPortMockRecorder) Component() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Component", reflect.TypeOf((*MockPort)(nil).Component))
}

// NotifyAvailable mocks base method
func (m *MockPort) NotifyAvailable(arg0 akita.VTimeInSec) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "NotifyAvailable", arg0)
}

// NotifyAvailable indicates an expected call of NotifyAvailable
func (mr *MockPortMockRecorder) NotifyAvailable(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotifyAvailable", reflect.TypeOf((*MockPort)(nil).NotifyAvailable), arg0)
}

// Peek mocks base method
func (m *MockPort) Peek() akita.Req {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Peek")
	ret0, _ := ret[0].(akita.Req)
	return ret0
}

// Peek indicates an expected call of Peek
func (mr *MockPortMockRecorder) Peek() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Peek", reflect.TypeOf((*MockPort)(nil).Peek))
}

// Recv mocks base method
func (m *MockPort) Recv(arg0 akita.Req) *akita.SendError {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Recv", arg0)
	ret0, _ := ret[0].(*akita.SendError)
	return ret0
}

// Recv indicates an expected call of Recv
func (mr *MockPortMockRecorder) Recv(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Recv", reflect.TypeOf((*MockPort)(nil).Recv), arg0)
}

// Retrieve mocks base method
func (m *MockPort) Retrieve(arg0 akita.VTimeInSec) akita.Req {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Retrieve", arg0)
	ret0, _ := ret[0].(akita.Req)
	return ret0
}

// Retrieve indicates an expected call of Retrieve
func (mr *MockPortMockRecorder) Retrieve(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Retrieve", reflect.TypeOf((*MockPort)(nil).Retrieve), arg0)
}

// Send mocks base method
func (m *MockPort) Send(arg0 akita.Req) *akita.SendError {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Send", arg0)
	ret0, _ := ret[0].(*akita.SendError)
	return ret0
}

// Send indicates an expected call of Send
func (mr *MockPortMockRecorder) Send(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Send", reflect.TypeOf((*MockPort)(nil).Send), arg0)
}

// SetConnection mocks base method
func (m *MockPort) SetConnection(arg0 akita.Connection) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetConnection", arg0)
}

// SetConnection indicates an expected call of SetConnection
func (mr *MockPortMockRecorder) SetConnection(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetConnection", reflect.TypeOf((*MockPort)(nil).SetConnection), arg0)
}
